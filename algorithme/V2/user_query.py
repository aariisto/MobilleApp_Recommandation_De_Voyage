from __future__ import annotations

from typing import List, Set


def _dedupe_keep_order(items: List[str]) -> List[str]:
    seen: Set[str] = set()
    out: List[str] = []
    for item in items:
        if item in seen:
            continue
        seen.add(item)
        out.append(item)
    return out


def _humanize_token(token: str) -> str:
    token = token.replace("_", " ")

    # Keep this aligned with dataS5/DONNEE_V2_ALGO/scripts/add_categories_gpt.py
    mapping = {
        "food and drink": "food and drink",
        "place of worship": "places of worship",
        "arts centre": "arts centres",
        "shopping mall": "shopping malls",
        "coffee shop": "coffee shops",
        "internet access": "internet access",
    }

    lower = token.lower()
    if lower in mapping:
        return mapping[lower]

    return token


def _join_natural(items: List[str]) -> str:
    items = [i for i in items if i]
    if not items:
        return ""
    if len(items) == 1:
        return items[0]
    if len(items) == 2:
        return f"{items[0]} and {items[1]}"
    return ", ".join(items[:-1]) + f", and {items[-1]}"


def _extract_leaf_values(categories: List[str], prefix: str) -> List[str]:
    values: List[str] = []
    for cat in categories:
        if not cat.startswith(prefix):
            continue
        leaf = cat[len(prefix) :]
        if leaf.startswith("."):
            leaf = leaf[1:]
        if not leaf:
            continue
        values.append(leaf.split(".")[-1])
    return _dedupe_keep_order(values)


def generate_user_query(user_categories: List[str]) -> str:
    """Transform raw category tags into a natural English sentence.

    The goal is to maximize MiniLM similarity with city descriptions generated by
    dataS5/DONNEE_V2_ALGO/scripts/add_categories_gpt.py.

    Rules:
    - Only emit concepts from the same allowed themes (Nature, History, Gastronomy, Shopping, Fun/Sport).
    - Use the exact same vocabulary "keys" as the city-side generator when tags are detected.
    """

    categories = [str(c).strip() for c in (user_categories or []) if str(c).strip()]
    cats_set: Set[str] = set(categories)

    def has_exact(value: str) -> bool:
        return value in cats_set

    def has_prefix(prefix: str) -> bool:
        for c in cats_set:
            if c == prefix or c.startswith(prefix + "."):
                return True
        return False

    # --- Nature ---
    has_nature = has_prefix("natural") or has_prefix("beach") or has_prefix("island") or has_prefix("national_park")

    # BUG 1 fix: collect multiple relevant nature details (don't swallow 'beach').
    nature_items: List[str] = []
    nature_items.extend(_extract_leaf_values(categories, "natural"))
    if has_prefix("beach"):
        nature_items.append("beach")
        nature_items.extend(_extract_leaf_values(categories, "beach"))
    if has_prefix("island"):
        nature_items.append("island")
        nature_items.extend(_extract_leaf_values(categories, "island"))
    if has_prefix("national_park"):
        nature_items.append("national_park")
        nature_items.extend(_extract_leaf_values(categories, "national_park"))
    nature_items = [_humanize_token(x) for x in nature_items]
    nature_items = _dedupe_keep_order(nature_items)[:3]

    # --- History ---
    has_history = (
        has_prefix("heritage")
        or has_prefix("tourism.sights")
        or has_prefix("religion")
        or has_prefix("memorial")
        or has_exact("building.historic")
    )

    sights_leaf = _extract_leaf_values(categories, "tourism.sights")
    sights_leaf = [_humanize_token(x) for x in sights_leaf]
    sights_leaf = _dedupe_keep_order(sights_leaf)

    preferred_sights = {
        "castle",
        "ruines",
        "monastery",
        "cathedral",
        "church",
        "chapel",
        "mosque",
        "synagogue",
        "temple",
        "archaeological site",
        "fort",
        "city gate",
    }
    sights_preferred = [s for s in sights_leaf if s.lower() in preferred_sights]
    sights_other = [s for s in sights_leaf if s.lower() not in preferred_sights]
    sights_final = (sights_preferred + sights_other)[:3]

    # --- Gastronomy ---
    has_restaurants = has_prefix("catering.restaurant")
    cuisines = _extract_leaf_values(categories, "catering.restaurant")
    cuisines_blacklist = {"restaurant", "regional"}
    cuisines_clean = [_humanize_token(c) for c in cuisines if c not in cuisines_blacklist]
    cuisines_clean = _dedupe_keep_order(cuisines_clean)[:3]

    has_winery = has_exact("production.winery") or has_prefix("production.winery")
    has_brewery = has_exact("production.brewery") or has_prefix("production.brewery")

    # --- Shopping (strict) ---
    has_shopping_mall = has_exact("commercial.shopping_mall")
    has_marketplace = has_exact("commercial.marketplace")
    has_souvenirs = has_exact("commercial.gift_and_souvenir")

    # --- Fun / Sport ---
    # BUG 2 fix: use prefix checks to catch sub-tags like 'adult.nightclub.*'
    has_nightclub = has_prefix("adult.nightclub")
    has_casino = has_prefix("adult.casino")
    has_theme_park = has_prefix("entertainment.theme_park")
    has_ski = has_prefix("ski")
    has_stadium = has_prefix("sport.stadium")

    # Build desire chunks using the exact same "keys" vocabulary
    chunks: List[str] = []

    if has_nature:
        if nature_items:
            chunks.append(f"beautiful landscapes like {_join_natural(nature_items)}")
        else:
            chunks.append("beautiful landscapes for nature lovers")

    if has_history:
        history_bits: List[str] = []
        if has_prefix("heritage"):
            history_bits.append("historical heritage")
        if sights_final:
            history_bits.append(f"landmarks like {_join_natural(sights_final)}")
        elif has_prefix("tourism.sights"):
            history_bits.append("iconic landmarks")
        if has_prefix("religion"):
            history_bits.append("religious sites")
        if has_prefix("memorial"):
            history_bits.append("memorials")
        if has_exact("building.historic") and "historical heritage" not in history_bits:
            history_bits.append("historic architecture")

        history_bits = _dedupe_keep_order(history_bits)
        if history_bits:
            chunks.append(_join_natural(history_bits))

    if has_restaurants or has_winery or has_brewery:
        food_bits: List[str] = []
        if has_restaurants:
            if cuisines_clean:
                food_bits.append(f"restaurants serving {_join_natural(cuisines_clean)} cuisine")
            else:
                food_bits.append("great local restaurants")
        if has_winery and has_brewery:
            food_bits.append("wineries and breweries")
        elif has_winery:
            food_bits.append("wineries")
        elif has_brewery:
            food_bits.append("breweries")

        food_bits = _dedupe_keep_order(food_bits)
        if food_bits:
            chunks.append(_join_natural(food_bits))

    shopping_bits: List[str] = []
    if has_shopping_mall:
        shopping_bits.append("shopping malls")
    if has_marketplace:
        shopping_bits.append("local marketplaces")
    if has_souvenirs:
        shopping_bits.append("souvenir shops")
    if shopping_bits:
        chunks.append(_join_natural(_dedupe_keep_order(shopping_bits)))

    fun_bits: List[str] = []
    if has_theme_park:
        fun_bits.append("theme parks")
    if has_ski:
        fun_bits.append("skiing")
    if has_stadium:
        fun_bits.append("stadium events")
    if has_nightclub and has_casino:
        fun_bits.append("nightlife and casinos")
    elif has_nightclub:
        fun_bits.append("nightlife")
    elif has_casino:
        fun_bits.append("casinos")

    fun_bits = _dedupe_keep_order(fun_bits)
    if fun_bits:
        chunks.append(_join_natural(fun_bits))

    chunks = _dedupe_keep_order(chunks)
    if not chunks:
        return "A destination offering a mix of travel experiences and local atmosphere."

    chunks = chunks[:3]
    return f"A destination featuring {_join_natural(chunks)}."


if __name__ == "__main__":
    # Quick manual sanity check
    example = [
      "accommodation",
      "accommodation.hotel",
      "building",
      "building.historic",
      "building.place_of_worship",
      "building.tourism",
      "catering",
      "catering.cafe",
      "catering.cafe.coffee",
      "catering.cafe.coffee_shop",
      "catering.restaurant",
      "catering.restaurant.arab",
      "catering.restaurant.international",
      "catering.restaurant.regional",
      "entertainment",
      "entertainment.museum",
      "heritage",
      "heritage.unesco",
      "highway",
      "highway.footway",
      "highway.pedestrian",
      "internet_access",
      "internet_access.free",
      "man_made",
      "memorial",
      "memorial.cemetery",
      "tourism",
      "tourism.attraction",
      "tourism.sights",
      "tourism.sights.archaeological_site",
      "tourism.sights.memorial",
      "tourism.sights.memorial.necropolis",
      "tourism.sights.memorial.tomb",
      "tourism.sights.ruines",
      "wheelchair",
      "wheelchair.yes"
    ]
    print(generate_user_query(example))
